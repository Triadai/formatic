<!DOCTYPE html><html lang="en"><head><title>components/fields/pretty-text2</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../"><meta name="groc-document-path" content="components/fields/pretty-text2"><meta name="groc-project-path" content="lib/components/fields/pretty-text2.js"><link rel="stylesheet" type="text/css" media="all" href="../../assets/style.css"><script type="text/javascript" src="../../assets/behavior.js"></script><body><div id="meta"><div class="file-path">lib/components/fields/pretty-text2.js</div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-pi">'use strict'</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>global CodeMirror </p></div></div><div class="code"><div class="wrapper"><span class="hljs-comment">/*eslint no-script-url:0 */</span>

<span class="hljs-keyword">var</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react/addons'</span>);
<span class="hljs-keyword">var</span> TagTranslator = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../helpers/tag-translator'</span>);
<span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'underscore'</span>);
<span class="hljs-keyword">var</span> cx = React.addons.classSet;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>   Editor for tagged text. Renders text like &quot;hello {{firstName}}&quot;
   with replacement labels rendered in a pill box. Designed to load
   quickly when many separate instances of it are on the same
   page.</p>
<p>   Uses CodeMirror to edit text. To save memory the CodeMirror node is
   instantiated when the user moves the mouse into the edit area.
   Initially a read-only view using a simple div is shown.</p>
<p>   IMPLEMENTATION NOTE:</p>
<p>   To display the tags inside CodeMirror we are using CM&#39;s
   specialCharPlaceholder feature, to replace special characters with
   custom DOM nodes. This feature is designed for single character
   replacements, not tags like &#39;firstName&#39;.  So we replace each tag
   with an unused character from the Unicode private use area, and
   tell CM to replace that with a DOM node display the tag label with
   the pill box effect.</p>
<p>   Is this evil? Perhaps a little, but delete, undo, redo, cut, copy
   and paste of the tag pill boxes just work because CM treats them as
   atomic single characters, and it&#39;s not much code on our part.</p></div></div><div class="code"><div class="wrapper">module.exports = React.createClass({
  displayName: <span class="hljs-string">'PrettyText'</span>,

  mixins: [<span class="hljs-built_in">require</span>(<span class="hljs-string">'../../mixins/field'</span>)],

  componentDidMount: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.createEditor();
  },

  componentDidUpdate: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(prevProps, prevState)</span> {</span>
    <span class="hljs-keyword">if</span> (prevState.codeMirrorMode !== <span class="hljs-keyword">this</span>.state.codeMirrorMode) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Changed from code mirror mode to read only mode or vice versa,
so setup the other editor.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">this</span>.createEditor();
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If they just typed in a tag like {{firstName}} we have to replace it</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.codeMirrorMode &amp;&amp; <span class="hljs-keyword">this</span>.codeMirror.getValue().match(<span class="hljs-regexp">/\{\{.+\}\}/</span>)) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>avoid recursive update cycle</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">this</span>.updatingCodeMirror = <span class="hljs-literal">true</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>get new encoded value for CodeMirror</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">var</span> cmValue = <span class="hljs-keyword">this</span>.codeMirror.getValue();
      <span class="hljs-keyword">var</span> decodedValue = <span class="hljs-keyword">this</span>.state.translator.decodeValue(cmValue);
      <span class="hljs-keyword">var</span> encodedValue = <span class="hljs-keyword">this</span>.state.translator.encodeValue(decodedValue);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Grab the cursor so we can reset it.
The new length of the CM value will be shorter after replacing a tag like {{firstName}}
with a single special char, so adjust cursor position accordingly.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">var</span> cursor = <span class="hljs-keyword">this</span>.codeMirror.getCursor();
      cursor.ch -= cmValue.length - encodedValue.length;

      <span class="hljs-keyword">this</span>.codeMirror.setValue(encodedValue);
      <span class="hljs-keyword">this</span>.codeMirror.setCursor(cursor);
    }
  },

  componentWillUnmount: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.codeMirrorMode) {
      <span class="hljs-keyword">this</span>.removeCodeMirrorEditor();
    }
  },

  getInitialState: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> replaceChoices = <span class="hljs-keyword">this</span>.props.config.fieldReplaceChoices(<span class="hljs-keyword">this</span>.props.field);
    <span class="hljs-keyword">var</span> translator = TagTranslator(replaceChoices, <span class="hljs-keyword">this</span>.props.config.humanize);

    <span class="hljs-keyword">return</span> {
      value: <span class="hljs-keyword">this</span>.props.field.value,
      codeMirrorMode: <span class="hljs-literal">false</span>,
      isChoicesOpen: <span class="hljs-literal">false</span>,
      replaceChoices: replaceChoices,
      translator: translator
    };
  },

  componentWillReceiveProps: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(nextProps)</span> {</span>
    <span class="hljs-keyword">var</span> replaceChoices = <span class="hljs-keyword">this</span>.props.config.fieldReplaceChoices(nextProps.field);
    <span class="hljs-keyword">var</span> nextState = {
      replaceChoices: replaceChoices
    };

    <span class="hljs-keyword">this</span>.state.translator.addChoices(replaceChoices);

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.value !== nextProps.field.value &amp;&amp; nextProps.field.value) {
      nextState.value = nextProps.field.value;
    }

    <span class="hljs-keyword">this</span>.setState(nextState);
  },

  handleChoiceSelection: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(key)</span> {</span>
    <span class="hljs-keyword">this</span>.setState({ isChoicesOpen: <span class="hljs-literal">false</span> });

    <span class="hljs-keyword">var</span> char = <span class="hljs-keyword">this</span>.state.translator.encodeTag(key);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>put the cursor at the end of the inserted tag.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.codeMirror.replaceSelection(char, <span class="hljs-string">'end'</span>);
    <span class="hljs-keyword">this</span>.codeMirror.focus();
  },

  render: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.renderWithConfig();
  },

  renderDefault: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> config = <span class="hljs-keyword">this</span>.props.config;
    <span class="hljs-keyword">var</span> field = <span class="hljs-keyword">this</span>.props.field;
    <span class="hljs-keyword">var</span> props = { field: field, plain: <span class="hljs-keyword">this</span>.props.plain };
    <span class="hljs-keyword">var</span> tabIndex = field.tabIndex;

    <span class="hljs-keyword">var</span> textBoxClasses = cx(_.extend({}, <span class="hljs-keyword">this</span>.props.classes, {<span class="hljs-string">'pretty-text-box'</span>: <span class="hljs-literal">true</span>}));
    <span class="hljs-keyword">var</span> textBox = <span class="hljs-keyword">this</span>.createTextBoxNode();

    <span class="hljs-keyword">var</span> choices = config.createElement(<span class="hljs-string">'choices'</span>, {
      ref: <span class="hljs-string">'choices'</span>,
      choices: <span class="hljs-keyword">this</span>.state.replaceChoices,
      open: <span class="hljs-keyword">this</span>.state.isChoicesOpen,
      ignoreCloseNodes: <span class="hljs-keyword">this</span>.getCloseIgnoreNodes,
      onSelect: <span class="hljs-keyword">this</span>.handleChoiceSelection,
      onClose: <span class="hljs-keyword">this</span>.onCloseChoices
    });</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Render read-only version. We are using pure HTML via dangerouslySetInnerHTML, to avoid
the cost of the react nodes. This is probably a premature optimization.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> element = (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">"pretty-content"</span> <span class="hljs-attribute">onMouseEnter</span>=<span class="hljs-value">{this.switchToCodeMirror}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">{textBoxClasses}</span> <span class="hljs-attribute">tabIndex</span>=<span class="hljs-value">{tabIndex}</span>&gt;</span>
          {textBox}
        <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">ref</span>=<span class="hljs-value">"toggle"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"Javascript:"</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.onToggleChoices}</span>&gt;</span>Insert...<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
        {choices}
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    );

    return config.createElement('field', props, element);
  },

  getCloseIgnoreNodes: function () {
    return this.refs.toggle.getDOMNode();
  },

  onToggleChoices: function () {
    this.setChoicesOpen(!this.state.isChoicesOpen);
  },

  setChoicesOpen: function (isOpen) {
    var action = isOpen ? 'open-replacements' : 'close-replacements';
    this.onStartAction(action);
    this.setState({ isChoicesOpen: isOpen });
  },

  onCloseChoices: function () {
    if (this.state.isChoicesOpen) {
      this.setChoicesOpen(false);
    }
  },

  createTextBoxNode: function () {
    if (this.state.codeMirrorMode) {
      return <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">ref</span>=<span class="hljs-value">"textBox"</span> /&gt;</span>;</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> html = <span class="hljs-keyword">this</span>.state.translator.toHtml(<span class="hljs-keyword">this</span>.state.value);
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">ref</span>=<span class="hljs-value">"textBox"</span> <span class="hljs-attribute">dangerouslySetInnerHTML</span>=<span class="hljs-value">{{__html:</span> <span class="hljs-attribute">html</span>}} /&gt;</span>;</span>
    }
  },

  createEditor: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.codeMirrorMode) {
      <span class="hljs-keyword">this</span>.createCodeMirrorEditor();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.createReadonlyEditor();
    }
  },

  createCodeMirrorEditor: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> cmValue = <span class="hljs-keyword">this</span>.state.translator.encodeValue(<span class="hljs-keyword">this</span>.state.value);

    <span class="hljs-keyword">var</span> options = {
      tabindex: <span class="hljs-keyword">this</span>.props.tabIndex,
      value: cmValue,
      specialChars: <span class="hljs-keyword">this</span>.state.translator.specialCharsRegexp,
      specialCharPlaceholder: <span class="hljs-keyword">this</span>.createTagNode,
      extraKeys: {
        Tab: <span class="hljs-literal">false</span>
      }
    };

    <span class="hljs-keyword">var</span> textBox = <span class="hljs-keyword">this</span>.refs.textBox.getDOMNode();
    textBox.innerHTML = <span class="hljs-string">''</span>; <span class="hljs-comment">// release any previous read-only content so it can be GC'ed</span>

    <span class="hljs-keyword">this</span>.codeMirror = CodeMirror(textBox, options);
    <span class="hljs-keyword">this</span>.codeMirror.on(<span class="hljs-string">'change'</span>, <span class="hljs-keyword">this</span>.onCodeMirrorChange);
  },

  onCodeMirrorChange: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.updatingCodeMirror) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>avoid recursive update cycle, and mark the code mirror manual update as done</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">this</span>.updatingCodeMirror = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> newValue = <span class="hljs-keyword">this</span>.state.translator.decodeValue(<span class="hljs-keyword">this</span>.codeMirror.getValue());
    <span class="hljs-keyword">this</span>.onChangeValue(newValue);
    <span class="hljs-keyword">this</span>.setState({value: newValue});
  },

  createReadonlyEditor: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> textBoxNode = <span class="hljs-keyword">this</span>.refs.textBox.getDOMNode();
    textBoxNode.innerHTML = <span class="hljs-keyword">this</span>.state.translator.toHtml(<span class="hljs-keyword">this</span>.state.value);
  },

  removeCodeMirrorEditor: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> textBoxNode = <span class="hljs-keyword">this</span>.refs.textBox.getDOMNode();
    <span class="hljs-keyword">var</span> cmNode = textBoxNode.firstChild;
    textBoxNode.removeChild(cmNode);
    <span class="hljs-keyword">this</span>.codeMirror = <span class="hljs-literal">null</span>;
  },

  switchToCodeMirror: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.state.codeMirrorMode) {
      <span class="hljs-keyword">this</span>.setState({codeMirrorMode: <span class="hljs-literal">true</span>});
    }
  },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create pill box style for display inside CM. For example
&#39;\ue000&#39; becomes &#39;&lt;span class=&quot;tag&gt;First Name</span>&#39;</p></div></div><div class="code"><div class="wrapper">  createTagNode: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(char)</span> {</span>
    <span class="hljs-keyword">var</span> node = document.createElement(<span class="hljs-string">'span'</span>);
    <span class="hljs-keyword">var</span> label = <span class="hljs-keyword">this</span>.state.translator.decodeChar(char);

    React.render(
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">span</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">"pretty-part"</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.onToggleChoices}</span>&gt;</span>{label}<span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>,
      node
    );
    return node;
  }
});
</span></div></div></div></div></body></html>