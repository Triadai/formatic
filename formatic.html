<!DOCTYPE html><html lang="en"><head><title>formatic</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="formatic"><meta name="groc-project-path" content="lib/formatic.js"><meta name="groc-github-url" content="https://github.com/zapier/formatic"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/zapier/formatic/blob/master/lib/formatic.js">lib/formatic.js</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="formatic">formatic</h1></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The root formatic component.</p>
<p>The root formatic component is actually two components. The main component is
a controlled component where you must pass the value in with each render. This
is actually wrapped in another component which allows you to use formatic as
an uncontrolled component where it retains the state of the value. The wrapper
is what is actually exported.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-pi">
'use strict'</span>;

<span class="hljs-keyword">var</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react/addons'</span>);
<span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'underscore'</span>);

<span class="hljs-keyword">var</span> utils = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./utils'</span>);

<span class="hljs-keyword">var</span> defaultConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./default-config'</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The main formatic component that renders the form.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> FormaticControlledClass = React.createClass({

  displayName: <span class="hljs-string">'FormaticControlled'</span>,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Respond to any value changes.</p></div></div><div class="code"><div class="wrapper">  onChange: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(newValue, info)</span> {</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.props.onChange) {
      <span class="hljs-keyword">return</span>;
    }
    info = _.extend({}, info);
    info.path = <span class="hljs-keyword">this</span>.props.config.fieldValuePath(info.field);
    <span class="hljs-keyword">this</span>.props.onChange(newValue, info);
  },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Respond to any actions other than value changes. (For example, focus and
blur.)</p></div></div><div class="code"><div class="wrapper">  onAction: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(info)</span> {</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.props.onAction) {
      <span class="hljs-keyword">return</span>;
    }
    info = _.extend({}, info);
    info.path = <span class="hljs-keyword">this</span>.props.config.fieldValuePath(info.field);
    <span class="hljs-keyword">this</span>.props.onAction(info);
  },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Render the root component by delegating to the config.</p></div></div><div class="code"><div class="wrapper">  render: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>

    <span class="hljs-keyword">var</span> config = <span class="hljs-keyword">this</span>.props.config;

    <span class="hljs-keyword">return</span> config.renderFormaticComponent(<span class="hljs-keyword">this</span>);
  }
});

<span class="hljs-keyword">var</span> FormaticControlled = React.createFactory(FormaticControlledClass);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A wrapper component that is actually exported and can allow formatic to be
used in an &quot;uncontrolled&quot; manner. (See uncontrolled components in the React
documentation for an explanation of the difference.)</p></div></div><div class="code"><div class="wrapper">module.exports = React.createClass({</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Export some stuff as statics.</p></div></div><div class="code"><div class="wrapper">  statics: {
    createConfig: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">var</span> args = _.toArray(<span class="hljs-built_in">arguments</span>);
      <span class="hljs-keyword">var</span> config = _.extend({}, defaultConfig);

      <span class="hljs-keyword">if</span> (args.length === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> config;
      }
      <span class="hljs-keyword">var</span> configs = [config].concat(args);
      <span class="hljs-keyword">return</span> configs.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(prev, curr)</span> {</span>
        <span class="hljs-keyword">if</span> (_.isFunction(curr)) {
          curr(prev);
          <span class="hljs-keyword">return</span> prev;
        }
        <span class="hljs-keyword">return</span> _.extend(prev, curr);
      });
    },
    availableMixins: {
      clickOutside: <span class="hljs-built_in">require</span>(<span class="hljs-string">'./mixins/click-outside.js'</span>),
      field: <span class="hljs-built_in">require</span>(<span class="hljs-string">'./mixins/field.js'</span>),
      helper: <span class="hljs-built_in">require</span>(<span class="hljs-string">'./mixins/helper.js'</span>),
      inputActions: <span class="hljs-built_in">require</span>(<span class="hljs-string">'./mixins/input-actions.js'</span>),
      resize: <span class="hljs-built_in">require</span>(<span class="hljs-string">'./mixins/resize.js'</span>),
      scroll: <span class="hljs-built_in">require</span>(<span class="hljs-string">'./mixins/scroll.js'</span>),
      undoStack: <span class="hljs-built_in">require</span>(<span class="hljs-string">'./mixins/undo-stack.js'</span>)
    },
    plugins: {
      bootstrap: <span class="hljs-built_in">require</span>(<span class="hljs-string">'./plugins/bootstrap'</span>),
      meta: <span class="hljs-built_in">require</span>(<span class="hljs-string">'./plugins/meta'</span>),
      reference: <span class="hljs-built_in">require</span>(<span class="hljs-string">'./plugins/reference'</span>)
    },
    utils: utils
  },

  displayName: <span class="hljs-string">'Formatic'</span>,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If we got a value, treat this component as controlled. Either way, retain
the value in the state.</p></div></div><div class="code"><div class="wrapper">  getInitialState: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> {
      isControlled: !_.isUndefined(<span class="hljs-keyword">this</span>.props.value),
      value: _.isUndefined(<span class="hljs-keyword">this</span>.props.value) ? <span class="hljs-keyword">this</span>.props.defaultValue : <span class="hljs-keyword">this</span>.props.value
    };
  },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If this is a controlled component, change our state to reflect the new
value. For uncontrolled components, ignore any value changes.</p></div></div><div class="code"><div class="wrapper">  componentWillReceiveProps: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(newProps)</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.isControlled) {
      <span class="hljs-keyword">if</span> (!_.isUndefined(newProps.value)) {
        <span class="hljs-keyword">this</span>.setState({
          value: newProps.value
        });
      }
    }
  },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If this is an uncontrolled component, set our state to reflect the new
value. Either way, call the onChange callback.</p></div></div><div class="code"><div class="wrapper">  onChange: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(newValue, info)</span> {</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.state.isControlled) {
      <span class="hljs-keyword">this</span>.setState({
        value: newValue
      });
    }
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.props.onChange) {
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">this</span>.props.onChange(newValue, info);
  },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Any actions should be sent to the generic onAction callback but also split
into discreet callbacks per action.</p></div></div><div class="code"><div class="wrapper">  onAction: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(info)</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.props.onAction) {
      <span class="hljs-keyword">this</span>.props.onAction(info);
    }
    <span class="hljs-keyword">var</span> action = utils.dashToPascal(info.action);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.props[<span class="hljs-string">'on'</span> + action]) {
      <span class="hljs-keyword">this</span>.props[<span class="hljs-string">'on'</span> + action](info);
    }
  },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Render the wrapper component (by just delegating to the main component).</p></div></div><div class="code"><div class="wrapper">  render: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>

    <span class="hljs-keyword">var</span> config = <span class="hljs-keyword">this</span>.props.config || defaultConfig;
    <span class="hljs-keyword">var</span> value = <span class="hljs-keyword">this</span>.state.value;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.isControlled) {
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.props.onChange) {
        console.log(<span class="hljs-string">'You should supply an onChange handler if you supply a value.'</span>);
      }
    }

    <span class="hljs-keyword">var</span> props = {
      config: config,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Allow field templates to be passed in as <code>field</code> or <code>fields</code>. After this, stop
calling them fields.</p></div></div><div class="code"><div class="wrapper">      fieldTemplate: <span class="hljs-keyword">this</span>.props.field,
      fieldTemplates: <span class="hljs-keyword">this</span>.props.fields,
      value: value,
      onChange: <span class="hljs-keyword">this</span>.onChange,
      onAction: <span class="hljs-keyword">this</span>.onAction
    };

    _.each(<span class="hljs-keyword">this</span>.props, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value, key)</span> {</span>
      <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> props)) {
        props[key] = value;
      }
    });

    <span class="hljs-keyword">return</span> FormaticControlled(props);
  }

});</div></div></div></div></body></html>